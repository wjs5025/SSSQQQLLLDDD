> 채점 현황 (맞은 개수/문항 수) : (11 / 19)

<hr/>

# 틀린 문항 오답노트

## 문제 130. 실행계획을 읽는 순서

```sql
NESTED LOOP     -- 1
    HASH JOIN   -- 2
        TABLE ACCESS (FULL) TAB1    -- 3
        TABLE ACCESS (FULL) TAB2    -- 4
    TABLE ACCESS (BY ROWID) TAB3    -- 5
        INDEX (UNIQUE SCAN) PK_TAB3 -- 6
```

- 실행계획은 안에서 밖으로, 위에서 아래로 읽는다.
  > 위 실행순서에서의 라인별 실행 순서는 3 - 4 - 2 - 6 - 5 - 1

## 문제 134. 관계형 데이터베이스의 인덱스에 대해.

- 자주 변경되는 속성은 인덱스로 정의하기에는 적절하지 않다. (DELETE, UPDATE 성능에 좋지 않은 영향을 미쳐서)

- 1. 기본인덱스 (PK INDEX)의 특징
  - 기본인덱스에는 중복된 키 값들이 나타날 수 없음.
  - 기본인덱스에는 널 값들이 나타날 수 있다.
- 2. 보조인덱스의 특징
  - 보조인덱스는 고유한 키 값이 아니어도 된다.

## 문제 135.관계형 데이터베이스의 인덱스에 대한 설명 (2)

- 테이블 전체를 읽을때는 인덱스가 거의 불필요함.
- 인덱스는 조회만을 위한 오브젝트이고, 삽입,삭제,갱신의 경우 오히려 부하를 증가시킨다.
- Balance Tree(B트리)는 관계형 데이터베이스에서 가장 많이 사용되는 트리이다.
- 인덱스가 존재하는 상황에서 데이터 입력 시, 매번 인덱스 정렬이 일어나서 대량의 데이터 삽입시에는 모든 인덱스 제거 하고, 삽입이 끝난 후 인덱스를 다시 생성하는 것이 좋음.

## 문제 136. 인덱스의 종류 (B-tree 인덱스 / bitmap 인덱스 / clustered 인덱스)

- 1. B-Tree 인덱스

  - 브랜치 블록과 리프 블록으로 구성.
  - 브랜치 블록은 분기를 목적으로 하고, 리프블록은 인덱스를 구성하는 컬럼의 값으로 정렬됨.
  - 일반적으로 OLTP 시스템 환경에서 가장 많이 사용.

- 2. Clustered 인덱스

  - 인덱스의 리프 페이지가 곧 데이터의 페이지.
  - 리프 페이지의 모든 데이터는 인덱스 키 컬럼 순으로 물리적으로 정렬되어 저장됨.

- 3. Bitmap 인덱스
  - 하나의 인덱스 키 엔트리가 많은 행에 대한 포인터를 저장하고 있는 구조.
  - 시스템에서 사용될 질의를 시스템 구현 시 모두 알 수 없는 경우인 DW 및 AD-HOC 질의 환경을 위해 설계됨.

## 문제 138. index의 생성 문장과 sql 실행 구문을 보고 적절한 것 고르는 문제.

```sql
-- INDEX 생성
CREATE INDEX IDX_EMP_01 ON EMP (REGIST_DATE, DEPTNO);

-- SQL 실행
SELECT *
FROM EMP
WHERE DEPTNO = 47
AND REGIST_DATE BETWEEN '2015.02.01' AND '2015.02.28';
```

- 실행된 SQL에 대해서 인덱스 비효율이 있어 인덱스의 컬럼을 DEPTNO + REGIST_DATE 순으로 변경할 필요가 있다.
- REGIST_DATE가 범위 조건이고 , DEPTNO 컬럼이 후행 컬럼이므로, IDX_EMP_01 인덱스로는 효율적인 검색을 할 수 없다.
- REGIST_DATE 컬럼에 대한 조건을 범위 검색이 아닌 동등 검색 조건으로 변경하면 IDX_EMP_01 인덱스를 효율적으로 활용할 수 있다.
- B-TREE 인덱스는 일반적으로 테이블 내의 데이터 중 10% 이하의 데이터를 검색할 때 유리하다.

## 문제 142. 옵티마이저 조인 종류

1. Nested loop Join (NL Join)

   - 프로그래밍에서 사용하는 중첩된 반복문과 유사한 방식으로 조인 수행
   - 랜덤 액세스 방식으로 데이터를 읽는다. 랜덤 액세스가 많이 발생하면 성능저하가 발생
   - 하나의 테이블에서 데이터를 먼저 찾고 그 다음 테이블을 조인하는 방식
   - **유니크 인덱스를** 활용해 수행시간이 적게 걸리는 소량 테이블을 온라인 조회하는 경우 유리함.
   - 조인 칼럼에 적당한 인덱스가 있어서 자연조인이 효율적일 때 유용
   - Driving table 의 개념이 중요하다. (Driving Table의 조인 데이터 양이 큰 영향을 준다.)
   - 선택도가 낮은 (결과 행의 수가 적은) 테이블이 선행테이블로 선택되는 것이 유리하다.

2. Sort Merge Join

   - 조인 칼럼을 기준으로 데이터를 정렬하여 조인 수행
   - 스캔 방식으로 데이터를 읽음
   - 두 개의 테이블을 SORT_AREA 라는 메모리 공간에 모두 로딩하고 정렬 수행
   - 정렬이 발생하기 때문에 **데이터가 많아지면 성능 저하**
   - 정렬 데이터 양이 너무 많으면 정렬은 임시 영역에서 수행.
   - 임시영역은 디스크에 있기 때문에 성능 급격히 저하
   - 조인조건의 인덱스 유무에 영향 받지 않는다.
   - Driving table 의 개념이 중요하지 않은 조인방식이다.
   - 조인칼럼에 적절한 인덱스가 없어서 NL조인이 비효율적일 때 사용가능

3. Hash Join
   - CPU 작업 위주로 처리. 해싱 기법 이용
   - **NL Join의 랜덤 액세스 문제**와 **Sort Merge Join의 정렬 작업 부담을 해결**하기 위한 대안으로 등장.
   - 두 개의 테이블 중 작은 테이블을 Hash 메모리에 로딩.
   - 두 개의 테이블 조인 키를 사용해서 해시 테이블 생성
   - 해시 함수를 사용해서 주소계산, 해당 주소를 사용해서 테이블을 조인하기 때문에, CPU 연산을 많이 함
   - Hash Join 시에는 선행 테이블의 크기가 작아서 충분한 메모리에 로딩되어야 한다.
   - EQUI (동등 = ) 조건에서만 동작한다.
   - 선택도가 높은 (결과 행의 수가 큰) 테이블을 선행테이블로 사용하는 것이 유리하다.
   - Sort Merge Join 보다 항상 우수한 성능을 보장한다.

## 문제 143. sql구문과 실행계획

- exists 절은 주로 SEMI JOIN으로 나타남.
- NESTED LOOP, HASH, SORT MERGE 셋에서 모두 SEME JOIN이 나타날 수 있지만, 인덱스 정보와 SQL을 고려해서 적절한 방식을 찾아야함.
  > 문제에서는 DEPTNO가 유니크한 키로 사용되어 NESTED LOOP INDEX가 더 적절하다고 판단됨.

## 문제 145. 해시조인이 더 효과적일 수 있는 조건

- 조인 컬럼에 적절한 인덱스가 없어서 자연 조인이 비효율 적일 때
- 자연 조인시 드라이빙 집합 쪽으로 조인 액세스량이 많아서 Random 액세스 부하가 심할때
- 소트 머지 조인을 하기에 두 테이블이 너무 커서 소트 부하가 심할 때

# 맞췄지만 헷갈렸던/중요한 개념 정리

## 옵티마이저의 정의, 종류

### 정의

- SQL의 실행계획을 수립하고 SQL을 실행하는 DBMS의 소프트웨어.
- SQL 문에 대한 최적의 실행방법 결정.
- 동일한 SQL 구문을 다른 순서로 실행 시, 결과는 변하지 않으나 성능은 변할 수 있다.

### 종류

- CBO (Cost based Optimizer)
  - 테이블, 인덱스, 칼럼, 오브젝트 통계 및 시스템 통계로 총 비용을 계산 후, 비용이 가장 적은 실행계획을 수립.
  - 통계 정보가 부적절하면 성능저하 발생.
- RBO (Rule based Optimizer)
  - 15개의 규칙에 우선순위를 두어 실행계획을 생성.

## 실행계획으로 알 수 있는 정보

- 액세스 기법
- 질의 처리 예상 비용
- 조인 순서
- 조인 기법
- 최적화 정보
- 연산

## 힌트(HINT)

- 개발자가 옵티마이저에게 실행계획을 알려주는 것.
