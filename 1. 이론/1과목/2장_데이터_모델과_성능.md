# 1과목 2장 데이터 모델과 성능

# '성능' 데이터 모델링

- 설계 단계의 데이터 모델링 때부터 정규화, 반정규화, 테이블 통합, 테이블 분할, 조인구조, PK, FK 등 여러가지 성능과 관련된 사항이 데이터 모델링에 반영될 수 있도록 하는 것.

- 성능 저하에 따른 유지보수 비용을 최소화 할 수 있다.

# 성능 데이터 모델링 고려사항 순서

1. 데이터 모델링을 할 때 정규화를 정확하게 수행
2. DB 용량 산정 수행
3. DB에 발생되는 트랜잭션의 유형 파악
4. 용량과 트랜잭션의 유형에 따라 반정규화 수행
5. 이력모델의 조정, PK/FK 조정, 슈퍼/서브타입 조정
6. 성능관점에서 데이터 모델을 검증

# 정규화

- 데이터 일관성, 최소한의 데이터 중복, 최대한의 데이터 유연성을 위한 방법, 데이터를 분해하는 과정
- 데이터 중복을 제거, 데이터 모델의 독립성 확보

# 정규화 절차

1. 1정규화 : 속성의 원자성 확보 / 기본키를 설정
2. 2정규화 : 기본키가 2개 이상의 속성으로 이루어진 경우.
3. 3정규화 : 기본키를 제외한 칼럼 간에 종속성 제거 (이행 함수 종속성 제거)
4. BCNF : 기본 키를 제외하고 후보키가 있는 경우, 후보키가 기본키를 종속시키면 분해
5. 4정규화 : 여러 칼럼들이 하나의 칼럼을 종속시키는 경우 분해하여 다중 값 종속성 제거
6. 5정규화 : 조인에 의해서 종속성이 발생되는 경우 분해

# 정규화의 문제점

- 데이터 조회(SELECT) 시에 조인\*을 유발하기 때문에 CPU와 메모리를 많이 사용

<hr/>

# 반정규화

- DB의 성능 향상을 위해 데이터 중복을 허용, 조인을 줄임.
- 조회 속도를 향상시키지만, 데이터 모델의 유연성은 낮아짐.

# 반정규화 절차

1. 대상 조사 및 검토 (데이터 처리 범위 / 빈도수 / 통계성)
2. 다른 방법 검토 (뷰 / 클러스터링 / 인덱스조정 / 응용프로그램 / 파티션)
3. 반정규화 수행 (테이블 / 속성/ 관계 등을 반정규화)

> **클러스터링** : 인덱스 정보를 저장할 때, 물리적으로 정렬해서 저장하는 방법. 조회 시에 인접 블록을 연속적으로 읽기때문에 성능이 향상\*된다.

# 반정규화 수행해야하는 경우 (반 정규화 대상 조사)

- 정규화에 충실(조인이 많음)하여 조회가 느려지는 경우.
- 다량의 범위를 자주 처리해야 하는 경우
- 특정 범위의 데이터만 자주 처리하는 경우
- 통계/집계 정보가 자주 요구되는 경우
- SORTING, ORDER BY는 반 정규화 대상이 아님.

# 다른 방법 검토

1. 지나치게 많은 조인이 걸려 데이터를 조회하는 작업이 기술적으로 어려울 경우 VIEW를 사용한다. \*VIEW : 가상테이블
2. 대량의 데이터 처리나 부분 처리에 의해 성능이 저하되는 경우, 클러스터링을 적용하거나 인덱스를 조정.
3. 대량의 데이터는 PK의 성격에 따라 부분적인 테이블로 분리할 수 있다. (파티셔닝 기법)
4. 응용 애플리케이션에서 로직을 구사하는 방법을 변경함으로써 성능을 향상시킬 수 있다.

# 반정규화 기법 5가지

- 테이블 병합
- 테이블 분할
- 테이블 추가
- 칼럼 반정규화
- 관계 반정규화

## 반정규화 기법 (테이블 반 정규화 - 테이블 병합\*)

1. 1:1 관계를 하나의 테이블로 병합하여 성능 향상
2. 1:M 관계를 하나의 테이블로 병합하여 성능 향상
3. 슈퍼/서브 관계를 통합하여 성능 향상

## 반정규화 기법 (테이블 반 정규화 - 테이블 분할\*)

1. 수직 분할 : 하나의 테이블을 두 개 이상의 테이블로 분할 한다. (칼럼을 기준으로 1:1 분리)
2. 수평 분할 : 하나의 테이블에 있는 값을 기준으로 테이블을 분할 (레코드를 기준으로 분리)

## 반정규화 기법 (테이블 반 정규화 - 테이블 추가)

1. 중복 테이블 추가
   - 다른 업무이거나 서버가 다른 경우 **동일한 테이블 구조를 중복**하여 원격조인을 제거하여 성능 향상
2. ## 통계 테이블 추가

- SUM, AVG 등을 미리 수행하여 계산해 둠으로써 조회 시 성능 향상

3. 이력 테이블 추가

- 이력 테이블 중에서 마스터 테이블에 존재하는 레코드를 중복하여 이력 테이블에 존재시켜 성능 향상

4. 부분 테이블 추가

- 하나의 테이블의 전체칼럼 중 자주 이용하는 집중화된 칼럼들이 있을 때, 디스크 I/O를 줄이기 위해 해당 칼럼들을 모아놓은 별도의 반정규화된 테이블을 생성.

## 반정규화 기법 (칼럼 반정규화)

1. 중복 칼럼

   - 조인에 의한 처리를 할 때 성능 저하를 예방하기 위해 중복된 칼럼을 위치시킴

2. 파생 칼럼

- 트랜잭션이 처리되는 시점에 계산에 의해 발생되는 성능저하를 예방 / 미리 값을 계산하여 칼럼에 보관.

3. 이력테이블

- 대량의 이력데이터를 처리할 때 불특정 일자 조회나 최근 값을 조회할 때 나타날 수 있는 성능 저하를 예방하기 위해 이력테이블에 기능성 칼럼( 쵝른값 여부, 시작과 종료일자)를 추가함

4. PK에 의한 칼럼 추가

- 이미 PK안에 데이터가 존재하지만 성능 향상을 위해 일반 속성으로 포함하는 경우

5. 응용시스템 오작동을 위한 칼럼 추가

- 업무적으로는 의미가 없지만 사용자의 실수로 원래 값으로 복구하기 원하는 경우 이전 데이터를 임시적으로 중복하여 보관하는 기법

## 반정규화 기법 (관계 반정규화)

- 중복 관계 추가 : 데이터를 처리하기 위한 여러 경로를 거쳐 조인이 가능하지만, 이 때 발생할 수 있는 성능 저하를 예방하기 위해 추가적인 관계를 맺는 방법

> 로우 체이닝 : 행의 길이가 너무 길어서 데이터 블록 하나에 데이터가 모두 저장되지 않고 두 개 이상의 블록에 걸쳐 하나의 행이 저장되어 있는 형태

> 로우 마이그레이션 : 데이터 블록에서 수정이 발생하면, 수정된 데이터를 해당 데이터블록에서 저장하지 못하고, 다른 블록의 빈 공간을 찾아 저장하는 방식

> 로우 체이닝과 로우 마이그레이션이 발생하면 많은 디스크 I/O가 발생하여 성능 저하 발생. 트랜잭션을 분석하여 적절하게 1:1 관계로 분리해야 한다.

# 파티셔닝 기법

- 파티션을 사용하여 테이블을 분할할 수 있다.
- 파티션을 사용하면 논리적으로는 하나의 테입르이지만, 여러 개의 데이터 파일에 분산되어 저장된다.

1. RANGE : 대상 테이블이 날짜 또는 숫자 값으로 분리가 가능하고, 각 영역별로 트랜잭션이 분리되는 경우.
2. LIST : 지점, 사업소 등 핵심적인 코드 값으로 PK가 구성되어 있고, 대량의 데이터가 있는 테이블의 경우
3. HASH : 지정된 HASH 조건에 따라 해쉬 알고리즘이 적용되어 테이블이 분리.

# 파티션 테이블의 장점

- 데이터 조회 시 접근 범위가 줄어들기 때문에 성능이 향상
- 데이터가 분할되어 있기 때문에 I/O 성능 향상
- 각 파티션을 독립적으로 백업/복구 가능
