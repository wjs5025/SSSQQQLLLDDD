# 윈도우 함수 (무조건 문제 풀기) (분석함수나 순위함수, 집계함수 등)

## over절

- 집계함수 범위지정
- 집계함수는 집계되지 않은 컬럼과 같이 사용할 수 없음.

```sql
-- 사용불가 ! (sal은 단일 컬럼, sum은 집계함수)
SELECT sal, sum(sal)
from employees;

```

## ROWS vs RANGE (범위지정)

- ROWS + between : 조회된 데이터를 물리적 위치로 구분해서 모든 행이 1개 행으로 인식.
- RANGE + between : order by 절에 명시된 칼럼으로 논리적인 행 집합을 구성해서, 집합으로 묶인 그룹이 1개 행으로 인식하게 함.

```sql
SELECT empno, ename, deptno, sal,
       SUM(sal) OVER(ORDER BY deptno, empno
                ROWS BETWEEN UNBOUNDED PRECEDING
                         AND UNBOUNDED FOLLOWING) sal1,
       SUM(sal) OVER(ORDER BY deptno, empno
                ROWS BETWEEN UNBOUNDED PRECEDING
                         AND CURRENT ROW) sal2,
       SUM(sal) OVER(ORDER BY deptno, empno
                ROWS BETWEEN CURRENT ROW
                         AND UNBOUNDED FOLLOWING) sal3
  FROM emp;
```

- unbounded preceding : 맨처음 로우
- unbounded following : 맨 마지막 로우

- 위 문장에서, sal1은 맨 처음 ~ 맨 끝의 물리적 rows의 합을 구해 리턴.
- 위 문장에서, sal2는 맨 처음 ~ 현재까지의 물리적 rows의 누적합을 구하는 식.
- sal3는 현재 ~ 맨끝 물리적 rows의 총합에 대해 앞부분 값을 제외하는 형식.

## RANK vs DENSE RANK (순위함수)

- RANK : 여러 등수 건너 뛴다 (1,1,3,4)
- DENSE RANK : 여러 등수 건너뛰지 않는다.( 1,1,2,3 )

## Partition by , order by

# 계층형 질의

## prior 자식데이터 = 부모데이터 ( 프 자 부 / 부 자 순)

- 부모데이터에서 자식으로 가는 경우 = 순방향
- 자식데이터에서 부모로 가는 경우 = 역방향

- 부모 데이터 = prior 자식데이터

- prior = 이전 행
  - 현재 레벨의 mgr이 이전 레벨의 empno와 같은지
    - mgr = prior empno

# 절차형 PL/SQL

- EXCEPTION : 생략 가능
- PROCEDURE, TRIGGER, USERDEFINED FUNCTION 차이점
  - TRIGGER : 커밋 롤백 안되고, DML 주로 쓰고
  - PROCEDURE : 반드시 값이 안나오고
  - USERDEFINED FUNCTION : 반드시 값이 나오고

# 데이터 모델링

- 복잡한 현실세계 (업무)
- 그러한 업무를 데이터 모델화

# 엔터티

- 업무상 관리하고자 하는 대상 (병원에서의 환자 등)
- 특징

  - 속성은 2개이상 (속성 = 인스턴스의 특징)
  - 인스턴스 2개이상
  - 관계는 하나이상
  - 업무에서 사용되어야 됨

- 엔터티 종류 (유개사 기중행)
  유개사 (유사엔터티 개념엔터티 사건엔터티)
  기중행 (기본엔터티, 중심엔터티, 행위엔터티)

# 속성의 종류 (기 설 파)

## 기본 속성

- 업무로부터 추출한 모든 일반적인 속성
  ex. 고객ID, 이름, 계좌번호, 주문일자

## 설계 속성

- 데이터 모델링 과정에서 발생되는 속성.
- 유일한 값을 부여
  ex. 상품 코드, 지점코드

## 파생 속성

- 다른 속성에 의해서 만들어지는 속성
  ex. 합계, 평균

# 도메인 (속성이 가질 수 있는 값의 범위)

- 데이터 유형, 크기 , 제약조건
  CHECK, PRIMARY KEY

# 관계

## 관계표기법

- ie : 네모나게 그리고 (pk가 제일 윗칸에 들어감 나머지는 아래칸에) / 필수 관계를 라인에 O , 선택관계를 으 모양으로
- Barker : 둥글게 그림 (pk는 #으로 쓰고 나머지는 O로) / 흐물흐물선 (OPTIONAL) 과 직선(필수)으로 분류

- 까마귀발은 동일

# 식별자

- erd에서 식별자와 비식별자 관계
- 점선은 비식별자, 실선은 식별자

## 주식별자 (유최불존)

- 유일성(인스턴스 유일하게구분) / 최소성(주식별자를 구성하는 속성 수는 1개여야한다) / 불변성(한번 만들면 바뀌지 않아야함) / 존재성(NULL이 아니어야한다.)
- 이것들을 다 만족하면 후보키가 될 수 있고, 대표로 선정되면 기본키(pk)가 된다.
- 대체키

# 식별자 관계 비식별자 관계

- 식별 : 강한 관계 (UML 상의 실선)
  - 단점 : SQL 구문 복잡 (PK 속성 수 증가)
- 비식별 : 약한 관계 (UML 상의 점선)
  - 단점 : 불필요한 조인이 많아져서 느려진다.

# ERD 서술 규칙

1. 시선 좌상 -> 우하
2. 관계명 반드시 표기 안해도됨
3. UML은 객체지향에서만 쓰인다.

# 성능 데이터 모델링

- 설계 단계의 데이터 모델링 때부터, [정규화, 반정규화, 테이블 통합, 테이블 분할, 조인구조, PK, FK] 등
  여러가지 성능과 관련된 사항이 데이터 모델링에 반영될 수 있도록 하는 것.

- 성능 저하에 따른 **유지보수 비용을 최소화** 할 수 있다.

## 아키텍처 개선, SQL명령문 개선

- 아키텍처 개선 : 데이터베이스 구조(테이블, 파티션) 등을 변경
- SQL 명령문 개선 : 조인 수행 원리 / 옵티마이저 / 실행계획
- 아키텍처 개선이 성능이 더 좋다.

# 정규화 (매우 중요, 정규화 수행방법 숙지 필수)

1차 : 원자성확보
2차 : 부분함수 종속성 제거 ** : 기본키가 2개 이상인 경우(복합키) 분리
3차 : 이행함수 종속성 제거 ** : 기본 키가 아닌 일반 컬럼에 의존하는 경우 이를 제거
bcnf

## 정규화 이상현상

- 삭제이상 삽입이상 등의 예시

## 정규화 성능

- SELECT 절에서는 JOIN 때문에 느려질 수 있음
- INSERT UPDATE 등에서는 성능이 좋아질 수 있다. (테이블이 작아지기 때문에)

# 반정규화

- 데이터 무결성을 해친다.

1. 대상분석(대량 범위, 범위 처리, 통계처리)

- 바로 반정규화 하지 않고, 다른 방법도 모색해봄. (응용 시스템 변경, 클러스터링/인덱스)

2. 다 해도 해결이 안될 것 같으면 반정규화

- 테이블 반정규화 (병합 - 1:1 1:m 슈퍼서브 / 분할 - 부분 테이블, 통계테이블, 중복테이블)
- 속성 반정규화 : 파생, 오류, 이력컬럼 추가, PK -> 일반 , 중복 속성
- 관계 반정규화 : 중복관계 추가

# 대량 데이터에 따른 성능 (특징이랑, 언제 발생 하는지 정도)

- ROW MIGRATION
- CHAINING

- 이걸 해결하기 위해 파티셔닝이 등장. (LIST, RANGE, HASH)
  - RANGE는 관리가 쉬움. (가장 많이 쓰임)
  - 해쉬가 관리가 정말 어려움.

# 슈퍼/서브 타입

- 용량별
  - 작은 경우 : ONE TO ONE (트랜잭션에 하나하나 개별로)
  - 큰 경우 : 트랜잭션
- 트랜잭션
  - 1. 공통/차이에 따라
  - 2. 전체 통합

# 분산데이터베이스

- 투명성
- 반정규화랑 유사
  - 데이터가 여러군데에 분산되어 있어서, 데이터 무결성을 해칠 수 있다.

# 조인 수행원리 (문제 많이 풀기)

- NL 조인(nested loops) : 랜덤 액세스, 대용량 소트 작업 유리
- Sort merge : 조인 키 정렬, 등가/비등가
- Hash 조인 : 등가 only / 선행테이블 작다 / hash 처리하기 때문에 별도 저장공간 필요

# 옵티마이저 (정의 정도만)

- CBO : 경로를 다 따랐을 때 제일 싼거.
- RBO : 규칙 기반

# 인덱스

- 인덱스 언제 사용되는지 (부정형, LIKE 함수, 묵시적 형변환)
- 인덱스 사용시 성능 저하. (insert, update, delete)
- select 시에는 성능 향상

# 실행계획

- 실행 순서 (내부에서 외부로)
- 들여쓰기 순으로 !
- 인덴트 레벨이 같으면 뭉텅이로 위에서부터 아래로

# 가장 중요한 포인트

정규화,
PIVOT, UNPIVOT
Merge
